{"version":3,"sources":["mustache.js","plugins.js"],"names":["global","factory","exports","define","amd","Mustache","this","mustache","isFunction","object","escapeRegExp","string","replace","testRegExp","re","RegExp_test","call","isWhitespace","nonSpaceRe","escapeHtml","String","s","entityMap","parseTemplate","template","tags","stripSpace","hasTag","nonSpace","spaces","length","tokens","pop","compileTags","split","spaceRe","isArray","Error","openingTagRe","RegExp","closingTagRe","closingCurlyRe","sections","start","type","value","chr","token","openSection","scanner","Scanner","eos","pos","scanUntil","i","valueLength","charAt","push","scan","tagRe","whiteRe","equalsRe","curlyRe","nestTokens","squashTokens","lastToken","squashedTokens","numTokens","section","nestedTokens","collector","tail","Context","view","parentContext","cache",".","parent","Writer","Object_toString","Object","prototype","toString","Array","test","&","<",">","\"","'","/","match","index","substring","search","lookup","name","names","context","indexOf","clearCache","parse","render","partials","renderTokens","originalTemplate","subRender","self","buffer","j","slice","escape","version","defaultWriter","to_html","send","result","$","fn","ajaxForm","options","settings","extend","action","method","replaceWithData","animateLoad","onFinish","submit","e","preventDefault","that","attr","ajaxAnimateLoad","ajax","url","data","serialize","success","textStatus","asm","log","replaceWith","error","jqXHR","errorThrown","jQuery","loaderImage","loaderWidth","loaderHeight","fadeDuration","backgroundDisabled","each","ajaxLoader","backgroundOverlay","children","append","animate","opacity","remove","ajaxLoadElm","callback","source","get","renderMustache","getJSON","html"],"mappings":"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","file":"core.js","sourcesContent":["/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (global, factory) {\n    if (typeof exports === \"object\" && exports) {\n        factory(exports); // CommonJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(['exports'], factory); // AMD\n    } else {\n        factory(global.Mustache = {}); // <script>\n    }\n}(this, function (mustache) {\n\n    var Object_toString = Object.prototype.toString;\n    var isArray = Array.isArray || function (object) {\n            return Object_toString.call(object) === '[object Array]';\n        };\n\n    function isFunction(object) {\n        return typeof object === 'function';\n    }\n\n    function escapeRegExp(string) {\n        return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n    }\n\n    // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n    // See https://github.com/janl/mustache.js/issues/189\n    var RegExp_test = RegExp.prototype.test;\n    function testRegExp(re, string) {\n        return RegExp_test.call(re, string);\n    }\n\n    var nonSpaceRe = /\\S/;\n    function isWhitespace(string) {\n        return !testRegExp(nonSpaceRe, string);\n    }\n\n    var entityMap = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': '&quot;',\n        \"'\": '&#39;',\n        \"/\": '&#x2F;'\n    };\n\n    function escapeHtml(string) {\n        return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n            return entityMap[s];\n        });\n    }\n\n    var whiteRe = /\\s*/;\n    var spaceRe = /\\s+/;\n    var equalsRe = /\\s*=/;\n    var curlyRe = /\\s*\\}/;\n    var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n    /**\n     * Breaks up the given `template` string into a tree of tokens. If the `tags`\n     * argument is given here it must be an array with two string values: the\n     * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n     * course, the default is to use mustaches (i.e. mustache.tags).\n     *\n     * A token is an array with at least 4 elements. The first element is the\n     * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n     * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n     * all text that appears outside a symbol this element is \"text\".\n     *\n     * The second element of a token is its \"value\". For mustache tags this is\n     * whatever else was inside the tag besides the opening symbol. For text tokens\n     * this is the text itself.\n     *\n     * The third and fourth elements of the token are the start and end indices,\n     * respectively, of the token in the original template.\n     *\n     * Tokens that are the root node of a subtree contain two more elements: 1) an\n     * array of tokens in the subtree and 2) the index in the original template at\n     * which the closing tag for that section begins.\n     */\n    function parseTemplate(template, tags) {\n        if (!template)\n            return [];\n\n        var sections = [];     // Stack to hold section tokens\n        var tokens = [];       // Buffer to hold the tokens\n        var spaces = [];       // Indices of whitespace tokens on the current line\n        var hasTag = false;    // Is there a {{tag}} on the current line?\n        var nonSpace = false;  // Is there a non-space char on the current line?\n\n        // Strips all whitespace tokens array for the current line\n        // if there was a {{#tag}} on it and otherwise only space.\n        function stripSpace() {\n            if (hasTag && !nonSpace) {\n                while (spaces.length)\n                    delete tokens[spaces.pop()];\n            } else {\n                spaces = [];\n            }\n\n            hasTag = false;\n            nonSpace = false;\n        }\n\n        var openingTagRe, closingTagRe, closingCurlyRe;\n        function compileTags(tags) {\n            if (typeof tags === 'string')\n                tags = tags.split(spaceRe, 2);\n\n            if (!isArray(tags) || tags.length !== 2)\n                throw new Error('Invalid tags: ' + tags);\n\n            openingTagRe = new RegExp(escapeRegExp(tags[0]) + '\\\\s*');\n            closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tags[1]));\n            closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tags[1]));\n        }\n\n        compileTags(tags || mustache.tags);\n\n        var scanner = new Scanner(template);\n\n        var start, type, value, chr, token, openSection;\n        while (!scanner.eos()) {\n            start = scanner.pos;\n\n            // Match any text between tags.\n            value = scanner.scanUntil(openingTagRe);\n\n            if (value) {\n                for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n                    chr = value.charAt(i);\n\n                    if (isWhitespace(chr)) {\n                        spaces.push(tokens.length);\n                    } else {\n                        nonSpace = true;\n                    }\n\n                    tokens.push([ 'text', chr, start, start + 1 ]);\n                    start += 1;\n\n                    // Check for whitespace on the current line.\n                    if (chr === '\\n')\n                        stripSpace();\n                }\n            }\n\n            // Match the opening tag.\n            if (!scanner.scan(openingTagRe))\n                break;\n\n            hasTag = true;\n\n            // Get the tag type.\n            type = scanner.scan(tagRe) || 'name';\n            scanner.scan(whiteRe);\n\n            // Get the tag value.\n            if (type === '=') {\n                value = scanner.scanUntil(equalsRe);\n                scanner.scan(equalsRe);\n                scanner.scanUntil(closingTagRe);\n            } else if (type === '{') {\n                value = scanner.scanUntil(closingCurlyRe);\n                scanner.scan(curlyRe);\n                scanner.scanUntil(closingTagRe);\n                type = '&';\n            } else {\n                value = scanner.scanUntil(closingTagRe);\n            }\n\n            // Match the closing tag.\n            if (!scanner.scan(closingTagRe))\n                throw new Error('Unclosed tag at ' + scanner.pos);\n\n            token = [ type, value, start, scanner.pos ];\n            tokens.push(token);\n\n            if (type === '#' || type === '^') {\n                sections.push(token);\n            } else if (type === '/') {\n                // Check section nesting.\n                openSection = sections.pop();\n\n                if (!openSection)\n                    throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n                if (openSection[1] !== value)\n                    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n            } else if (type === 'name' || type === '{' || type === '&') {\n                nonSpace = true;\n            } else if (type === '=') {\n                // Set the tags for the next time around.\n                compileTags(value);\n            }\n        }\n\n        // Make sure there are no open sections when we're done.\n        openSection = sections.pop();\n\n        if (openSection)\n            throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n        return nestTokens(squashTokens(tokens));\n    }\n\n    /**\n     * Combines the values of consecutive text tokens in the given `tokens` array\n     * to a single token.\n     */\n    function squashTokens(tokens) {\n        var squashedTokens = [];\n\n        var token, lastToken;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            token = tokens[i];\n\n            if (token) {\n                if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n                    lastToken[1] += token[1];\n                    lastToken[3] = token[3];\n                } else {\n                    squashedTokens.push(token);\n                    lastToken = token;\n                }\n            }\n        }\n\n        return squashedTokens;\n    }\n\n    /**\n     * Forms the given array of `tokens` into a nested tree structure where\n     * tokens that represent a section have two additional items: 1) an array of\n     * all tokens that appear in that section and 2) the index in the original\n     * template that represents the end of that section.\n     */\n    function nestTokens(tokens) {\n        var nestedTokens = [];\n        var collector = nestedTokens;\n        var sections = [];\n\n        var token, section;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            token = tokens[i];\n\n            switch (token[0]) {\n                case '#':\n                case '^':\n                    collector.push(token);\n                    sections.push(token);\n                    collector = token[4] = [];\n                    break;\n                case '/':\n                    section = sections.pop();\n                    section[5] = token[2];\n                    collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n                    break;\n                default:\n                    collector.push(token);\n            }\n        }\n\n        return nestedTokens;\n    }\n\n    /**\n     * A simple string scanner that is used by the template parser to find\n     * tokens in template strings.\n     */\n    function Scanner(string) {\n        this.string = string;\n        this.tail = string;\n        this.pos = 0;\n    }\n\n    /**\n     * Returns `true` if the tail is empty (end of string).\n     */\n    Scanner.prototype.eos = function () {\n        return this.tail === \"\";\n    };\n\n    /**\n     * Tries to match the given regular expression at the current position.\n     * Returns the matched text if it can match, the empty string otherwise.\n     */\n    Scanner.prototype.scan = function (re) {\n        var match = this.tail.match(re);\n\n        if (!match || match.index !== 0)\n            return '';\n\n        var string = match[0];\n\n        this.tail = this.tail.substring(string.length);\n        this.pos += string.length;\n\n        return string;\n    };\n\n    /**\n     * Skips all text until the given regular expression can be matched. Returns\n     * the skipped string, which is the entire tail if no match can be made.\n     */\n    Scanner.prototype.scanUntil = function (re) {\n        var index = this.tail.search(re), match;\n\n        switch (index) {\n            case -1:\n                match = this.tail;\n                this.tail = \"\";\n                break;\n            case 0:\n                match = \"\";\n                break;\n            default:\n                match = this.tail.substring(0, index);\n                this.tail = this.tail.substring(index);\n        }\n\n        this.pos += match.length;\n\n        return match;\n    };\n\n    /**\n     * Represents a rendering context by wrapping a view object and\n     * maintaining a reference to the parent context.\n     */\n    function Context(view, parentContext) {\n        this.view = view == null ? {} : view;\n        this.cache = { '.': this.view };\n        this.parent = parentContext;\n    }\n\n    /**\n     * Creates a new context using the given view with this context\n     * as the parent.\n     */\n    Context.prototype.push = function (view) {\n        return new Context(view, this);\n    };\n\n    /**\n     * Returns the value of the given name in this context, traversing\n     * up the context hierarchy if the value is absent in this context's view.\n     */\n    Context.prototype.lookup = function (name) {\n        var cache = this.cache;\n\n        var value;\n        if (name in cache) {\n            value = cache[name];\n        } else {\n            var context = this, names, index;\n\n            while (context) {\n                if (name.indexOf('.') > 0) {\n                    value = context.view;\n                    names = name.split('.');\n                    index = 0;\n\n                    while (value != null && index < names.length)\n                        value = value[names[index++]];\n                } else {\n                    value = context.view[name];\n                }\n\n                if (value != null)\n                    break;\n\n                context = context.parent;\n            }\n\n            cache[name] = value;\n        }\n\n        if (isFunction(value))\n            value = value.call(this.view);\n\n        return value;\n    };\n\n    /**\n     * A Writer knows how to take a stream of tokens and render them to a\n     * string, given a context. It also maintains a cache of templates to\n     * avoid the need to parse the same template twice.\n     */\n    function Writer() {\n        this.cache = {};\n    }\n\n    /**\n     * Clears all cached templates in this writer.\n     */\n    Writer.prototype.clearCache = function () {\n        this.cache = {};\n    };\n\n    /**\n     * Parses and caches the given `template` and returns the array of tokens\n     * that is generated from the parse.\n     */\n    Writer.prototype.parse = function (template, tags) {\n        var cache = this.cache;\n        var tokens = cache[template];\n\n        if (tokens == null)\n            tokens = cache[template] = parseTemplate(template, tags);\n\n        return tokens;\n    };\n\n    /**\n     * High-level method that is used to render the given `template` with\n     * the given `view`.\n     *\n     * The optional `partials` argument may be an object that contains the\n     * names and templates of partials that are used in the template. It may\n     * also be a function that is used to load partial templates on the fly\n     * that takes a single argument: the name of the partial.\n     */\n    Writer.prototype.render = function (template, view, partials) {\n        var tokens = this.parse(template);\n        var context = (view instanceof Context) ? view : new Context(view);\n        return this.renderTokens(tokens, context, partials, template);\n    };\n\n    /**\n     * Low-level method that renders the given array of `tokens` using\n     * the given `context` and `partials`.\n     *\n     * Note: The `originalTemplate` is only ever used to extract the portion\n     * of the original template that was contained in a higher-order section.\n     * If the template doesn't use higher-order sections, this argument may\n     * be omitted.\n     */\n    Writer.prototype.renderTokens = function (tokens, context, partials, originalTemplate) {\n        var buffer = '';\n\n        // This function is used to render an arbitrary template\n        // in the current context by higher-order sections.\n        var self = this;\n        function subRender(template) {\n            return self.render(template, context, partials);\n        }\n\n        var token, value;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            token = tokens[i];\n\n            switch (token[0]) {\n                case '#':\n                    value = context.lookup(token[1]);\n\n                    if (!value)\n                        continue;\n\n                    if (isArray(value)) {\n                        for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n                            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n                        }\n                    } else if (typeof value === 'object' || typeof value === 'string') {\n                        buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n                    } else if (isFunction(value)) {\n                        if (typeof originalTemplate !== 'string')\n                            throw new Error('Cannot use higher-order sections without the original template');\n\n                        // Extract the portion of the original template that the section contains.\n                        value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n                        if (value != null)\n                            buffer += value;\n                    } else {\n                        buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n                    }\n\n                    break;\n                case '^':\n                    value = context.lookup(token[1]);\n\n                    // Use JavaScript's definition of falsy. Include empty arrays.\n                    // See https://github.com/janl/mustache.js/issues/186\n                    if (!value || (isArray(value) && value.length === 0))\n                        buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n\n                    break;\n                case '>':\n                    if (!partials)\n                        continue;\n\n                    value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n\n                    if (value != null)\n                        buffer += this.renderTokens(this.parse(value), context, partials, value);\n\n                    break;\n                case '&':\n                    value = context.lookup(token[1]);\n\n                    if (value != null)\n                        buffer += value;\n\n                    break;\n                case 'name':\n                    value = context.lookup(token[1]);\n\n                    if (value != null)\n                        buffer += mustache.escape(value);\n\n                    break;\n                case 'text':\n                    buffer += token[1];\n                    break;\n            }\n        }\n\n        return buffer;\n    };\n\n    mustache.name = \"mustache.js\";\n    mustache.version = \"0.8.1\";\n    mustache.tags = [ \"{{\", \"}}\" ];\n\n    // All high-level mustache.* functions use this writer.\n    var defaultWriter = new Writer();\n\n    /**\n     * Clears all cached templates in the default writer.\n     */\n    mustache.clearCache = function () {\n        return defaultWriter.clearCache();\n    };\n\n    /**\n     * Parses and caches the given template in the default writer and returns the\n     * array of tokens it contains. Doing this ahead of time avoids the need to\n     * parse templates on the fly as they are rendered.\n     */\n    mustache.parse = function (template, tags) {\n        return defaultWriter.parse(template, tags);\n    };\n\n    /**\n     * Renders the `template` with the given `view` and `partials` using the\n     * default writer.\n     */\n    mustache.render = function (template, view, partials) {\n        return defaultWriter.render(template, view, partials);\n    };\n\n    // This is here for backwards compatibility with 0.4.x.\n    mustache.to_html = function (template, view, partials, send) {\n        var result = mustache.render(template, view, partials);\n\n        if (isFunction(send)) {\n            send(result);\n        } else {\n            return result;\n        }\n    };\n\n    // Export the escaping function so that the user may override it.\n    // See https://github.com/janl/mustache.js/issues/244\n    mustache.escape = escapeHtml;\n\n    // Export these mainly for testing, but also for advanced usage.\n    mustache.Scanner = Scanner;\n    mustache.Context = Context;\n    mustache.Writer = Writer;\n\n}));\n","// Place any jQuery/helper plugins in here.\n\n(function ($) {\n    $.fn.ajaxForm = function (options) {\n        var settings = $.extend({\n            action: \"\",\n            method: \"\",\n            replaceWithData: true,\n            animateLoad: true,\n            onFinish: null\n        }, options);\n\n        try {\n            this.submit(function (e) {\n                e.preventDefault();\n\n                //get the url for the form\n                var that = $(this);\n\n                if (\"\" == settings.action) {\n                    settings.action = that.attr('action');\n                }\n\n                if (\"\" == settings.method) {\n                    settings.method = that.attr('method');\n                }\n\n                if (true == settings.animateLoad) {\n                    that.ajaxAnimateLoad();\n                }\n\n                $.ajax({\n                    type: settings.method,\n                    url: settings.action,\n                    data: that.serialize(),\n                    success: function (data, textStatus, jqXHR) {\n                        asm.log('form::response: ' + textStatus);\n                        if (true == settings.replaceWithData) {\n                            that.replaceWith(data);\n                        }\n\n                        if (typeof settings.onFinish === 'function') {\n                            settings.onFinish(self);\n                        }\n                    },\n                    error: function (jqXHR, textStatus, errorThrown) {\n                        asm.log('form::response: ' + errorThrown);\n                        that.replaceWith(jqXHR);\n                        that.ajaxForm(settings);\n                    }\n                });\n            });\n\n            return false;\n        } catch (e) {\n            asm.log(e);\n        }\n    };\n}(jQuery));\n\n/**\n * jQuery ajax loader plugin\n */\n(function ($) {\n    $.fn.ajaxAnimateLoad = function (options) {\n        // Create some defaults, extending them with any options that were provided\n        var settings = $.extend({\n            loaderImage: '/img/ajax-loader.gif',\n            loaderWidth: '32px',\n            loaderHeight: '32px',\n            fadeDuration: 200,\n            action: 'start',\n            backgroundDisabled: false\n        }, options);\n\n        return this.each(function () {\n            var that = $(this),\n                ajaxLoader = '<span id=\"ajaxloader\" style=\"display: block; width: '\n                    + settings.loaderWidth + '; height: '\n                    + settings.loaderHeight + '; background: transparent url('\n                    + settings.loaderImage\n                    + ') no-repeat center center; position: absolute; top: 50%; left: 50%;\">&nbsp;</span>';\n\n            var backgroundOverlay = '<div class=\"modalBackgroundOverlay\" style=\"position: fixed; width:100%; ' +\n                'height: 100%; top: 0px; left: 0px; zoom: 1; opacity: 0.0; background-color: #FFF; ' +\n                'z-index: 201;\">&nbsp;</div>';\n\n            if (settings.action == 'start') {\n                if (true == settings.backgroundDisabled) {\n                    if (that.children('.modalBackgroundOverlay').length == 0) {\n                        that.append(backgroundOverlay);\n                        jQuery('.modalBackgroundOverlay').animate({opacity: 0.4}, settings.fadeDuration);\n                    }\n                    if (that.children('#ajaxloader').length == 0) {\n                        that.append(ajaxLoader);\n                    }\n                } else {\n                    that.attr('style', 'position: relative;').append(ajaxLoader).animate({opacity: 0.4}, settings.fadeDuration);\n                }\n            } else if (settings.action == 'stop') {\n                if (that.children('.modalBackgroundOverlay').length > 0) {\n                    that.children('#ajaxloader').remove();\n                    that.children('.modalBackgroundOverlay').animate({opacity: 0.0}, settings.fadeDuration).remove();\n                } else {\n                    that.attr('style', 'position: static;').remove(\"#ajaxloader\").animate({opacity: 1.0}, settings.fadeDuration);\n                }\n            }\n        });\n    };\n})(jQuery);\n\n/**\n * ajax load a url into target, using loader animation\n */\n(function ($) {\n    $.fn.ajaxLoadElm = function (options, callback) {\n\n        // Create some defaults, extending them with any options that were provided\n        var settings = $.extend({\n                source: '',\n                animateLoad: true,\n                backgroundDisabled: false\n            }, options),\n            that = $(this);\n\n        try {\n            if (true == settings.animateLoad) {\n                that.ajaxAnimateLoad({'backgroundDisabled': settings.backgroundDisabled});\n            }\n\n            $.get(settings.source, function (data) {\n                that.replaceWith(data);\n            });\n\n            if (typeof callback == 'function') { // make sure the callback is a function\n                callback.call(this); // brings the scope to the callback\n            }\n\n            return false;\n        }\n        catch (e) {\n            asm.log(e);\n        }\n    };\n})(jQuery);\n\n/**\n * mustache auto-renderer\n */\n(function ($) {\n    $.fn.renderMustache = function (options) {\n\n        var settings = $.extend({\n                source: \"\",\n                template: \"\"\n            }, options),\n            that = $(this);\n\n        if (\"\" == settings.source) {\n            settings.url = that.data('source');\n        }\n\n        if (\"\"  == settings.template) {\n            settings.template = that.data('template');\n        }\n\n        $.getJSON(settings.source, function(data) {\n            if (data.length > 0) {\n                that.html(\n                    Mustache.render(\n                        $(settings.template).html(),\n                        data\n                    )\n                );\n                asm.log('mustache::refreshed ' + settings.template);\n            } else {\n                asm.log('mustache::no elements found for ' + settings.source);\n            }\n        });\n    };\n})(jQuery);\n"],"sourceRoot":"/source/"}